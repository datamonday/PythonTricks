由于计算机中本质上所有的东西以为二进制存储和操作的，为了方便表示二进制值，所以就搞了一些单位。

位

- bit (b)

  ```shell
  表示二进制有多少位，例如：
    01101      5位 = 5b
    011011010  9位 = 9b
  ```

  

字节
- byte (B)

  ```shell
  8位就是1个字节，例如：
    10100101             8位 = 8b = 1B = 1个字节
    1010010110100101     16位 = 16b = 2B = 2个字节
  ```



千字节

- Kilobyte (KB)

  ```shell
  1024个千字节就是1兆（1M)，即：
    1M = 1024 KB = 1024 * 1024 B = 1024 * 1024 * 8 b
  ```



---

# ascii

ascii码规定用8位来表示一个字符。因为每一位有0/1两种可能，8位就可以支持256种可能，即：从 0000000、00000001、00000010 ~ 11111111 有256个，ascii就是这些二进制和字符来做的对应关系。

---

# unicode

由于ascii码只能表示256中字符对照关系，无法表示其他国家的文字，为了能让计算机支持全世界任意的文字，推出了unicode（字符集），它为全世界已知语言的所有字符都分配了一个码位（相当于是一个身份证ID），码位本质上也是个二进制。unicode字符集 和 ascii编码区别如下：

- ascii编码，直接是字符和二进制的对照表，此二进制可在计算机中用于 `内存计算`、`硬盘存储`、`网络传输`等。

  ```python
  字符    二进制
   a    01100001（十进制97；十六进制61）
   b    01100010（十进制98；十六进制62）
  ```

  

- unicode字符集，是字符和码位的对应关系，码位本质上也是二进制，此二进制可在计算机中用于`内存计算`，但一般不会做`硬盘存储`和`网络传输`。

  ```python
  字符           码位（ID）
   a    00000000 01100001（十进制97；十六进制61）
   b    00000000 01100010（十进制98；十六进制62）
   武   01101011 01100110（十进制27494；十六进制6B66）
   갵   10101100 00110101（十进制44085；十六进制AC35）
  ```

  

- utf-8编码，是对unicode字符集的码位进行转换处理得到的二进制，此二进制可用于 `内存计算`、`硬盘存储`、`网络传输`等。

  ```python
  字符           码位（ID）                             utf-8编码（可以对码位进行加工处理）
   a    00000000 01100001（十进制97；十六进制61）            01100001
   b    00000000 01100010（十进制98；十六进制62）            01100010
   武   01101011 01100110（十进制27494；十六进制6B66）       11100110 10101101 10100110
   갵   10101100 00110101（十进制44085；十六进制AC35）       11101010 10110000 10110101
  注意：这样一来utf-8编码的二级制和字符就生成了一个间接的对照表。
  ```

  

---

起初unicode字符集固定使用2个字节来表示码位，即：ucs2。

```python
ucs2用2个字节表示码位，所以码位能表示从 0000000000000000 至 1111111111111111 共 2**16=65525种可能，同时意味着ucs2能表示65535个字符。

用十六进制表示这个范围的话就是：0000 ~ FFFF。

ucs2中字符和码位的对应关系参见：http://www.columbia.edu/kermit/ucs2.html
```

后来unicode使用4个字节表示所有字符，即：ucs4。

```python
因为随着时间的推移，发现的字符越来越多，这65535不够用了。

所以就有了ucs4，它使用固定4个字节表示码位，码位就可以表示 2**32 = 4294967296 种可能，范围如下：

  二进制表示   00000000 00000000 00000000 00000000 ~ 11111111 11111111 11111111 11111111
  十六进制表示                            00000000 ~ ffffffff

ucs4中字符和码位的具体对应关系参见：
	https://unicode-table.com/en/#00A5
	https://www.unicode.org/charts/
```

ucs4的优缺点：

- 缺点：因为都**使用4个字节表示码位**，同样的字符的码位会更占空间。所以，计算机中再`网络传输`、`硬盘存储`时都不会用unicode字符集的码位存储，而是把码位转换（压缩）成utf-8等编码的二进制再进行传输和硬盘存储。
- 优点：可以表示所有字符并且长度固定4字节，方便内存中进行数据计算（不必担心太占用内存空间，因为内存占用的计算的数据一般不会太大）。

注：网络传输指的是通过网络发送一段文字等消息； 硬盘存储指的是把一些文档等信息保存到硬盘上。

---

# utf-8

**utf-8编码其实就是对unicode字符集的码位进行压缩加工处理得到的，把二进制码位中不必要位去掉**。这样一来，utf-8既可以表示所有的字符，又可以进行内存计算、网络传输、硬盘存储了，所以，这也是为什么utf-8编码可以在全球的广泛的应用。

**utf-8是以 8 位为一个编码单位的可变长编码**。会将一个码位编码为 1 到 4 个字节，对于码位进行编码时分为两步：

- **第一步**：根据码位选择转换模板

  ```python
   码位范围（十六进制）                转换模板
     0000 ~ 007F              0XXXXXXX
     0080 ~ 07FF              110XXXXX 10XXXXXX
     0800 ~ FFFF              1110XXXX 10XXXXXX 10XXXXXX
    10000 ~ 10FFFF            11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
    
  例如：
  	"B"  对应的unicode码位为 0042，那么他应该选择的一个模板。
      "ǣ"  对应的unicode码位为 01E3，则应该选择第二个模板。
  	"武" 对应的unicode码位为 6B66，则应该选择第三个模板。
  ```

- **第二步**：码位以二进制展示，再根据模板进行转换

  ```python
  码位拆分： "武"的码位为6B66，则二进制为 0110101101100110
  
  根据模板转换：
      6    B    6    6
      0110 1011 0110 0110
      ----------------------------
      1110XXXX 10XXXXXX 10XXXXXX    使用第三个模板
      11100110 10XXXXXX 10XXXXXX    第一步：取二进制前四位0110填充到模板的第一个字节的xxxx位置
      11100110 10101101 10XXXXXX    第二步：挨着向后取6位101101填充到模板的第二个字节的xxxxxx位置
      11100110 10101101 10100110    第三步：再挨着向后取6位100110填充到模板的第三个字节的xxxxxx位置
  最终，"武"对应的utf-8编码为 11100110 10101101 10100110
  ```

  

---

对本节所有的知识点进行归纳总结：

1. 计算机上所有的东西最终都会转换成为二进制再去运行。
2. ascii编码、unicode字符集、utf-8编码本质上都是字符与二进制的关系。
   - ascii，字符和二进制的对照表。
   - unicode，字符和二进制（码位）的对照表。
   - utf-8，对unicode字符集的码位进行压缩处理，间接也维护了字符和二进制的对照表。
3. ucs2和ucs4指的是使用多少个字节来表示unicode字符集的码位。
4. 目前最广泛的编码为：utf-8，它可以表示所有的字符且存储或网络传输也不会浪费资源（**对码位进行压缩**了）。

---

Reference：https://pythonav.com/wiki/detail/1/80/

